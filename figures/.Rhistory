dat=totalmers,
model=models[i])
}
#make a table output with all of the relevant information
result.comp <-as.data.frame(matrix(,7,48))
colnames(result.comp)<- c("model","results.bp.Mbp", "aic","par1","par1","par1","model","results.twomers", "aic","par1","par1","par1","model","results.threemers", "aic","par1","par1","par1" ,"model","results.threemers", "aic","par1","par1","par1", "model", "results.fourmers", "aic","par1","par1","par1", "model","results.fivemers", "aic","par1","par1","par1", "model","results.sixmers", "aic","par1","par1","par1", "model","results.totalmers", "aic","par1","par1","par1")
for(i in 1:7){
result.comp[i,1]<-models[i]
result.comp[i,2]<-"trees"
result.comp[i,3]<- results.bp.Mbp[[i]]$opt$aicc
result.comp[i,4]<- results.bp.Mbp[[i]]$opt[1]
result.comp[i,5]<- results.bp.Mbp[[i]]$opt[2]
result.comp[i,6]<- results.bp.Mbp[[i]]$opt[3]
}
for(i in 1:7){
result.comp[i,7]<-models[i]
result.comp[i,8]<-"trees"
result.comp[i,9]<- results.twomers[[i]]$opt$aicc
result.comp[i,10]<- results.twomers[[i]]$opt[1]
result.comp[i,11]<- results.twomers[[i]]$opt[2]
result.comp[i,12]<- results.twomers[[i]]$opt[3]
}
for(i in 1:7){
result.comp[i,13]<-models[i]
result.comp[i,14]<-"trees"
result.comp[i,15]<- results.threemers[[i]]$opt$aicc
result.comp[i,16]<- results.threemers[[i]]$opt[1]
result.comp[i,17]<- results.threemers[[i]]$opt[2]
result.comp[i,18]<- results.threemers[[i]]$opt[3]
}
View(result.comp)
for(i in 1:7){
result.comp[i,25]<-models[i]
result.comp[i,26]<-"trees"
result.comp[i,27]<- results.fivemers[[i]]$opt$aicc
result.comp[i,28]<- results.fivemers[[i]]$opt[1]
result.comp[i,29]<- results.fivemers[[i]]$opt[2]
result.comp[i,30]<- results.fivemers[[i]]$opt[3]
}
#fill in sixmers model data
for(i in 1:7){
result.comp[i,31]<-models[i]
result.comp[i,32]<-"trees"
result.comp[i,33]<- results.sixmers[[i]]$opt$aicc
result.comp[i,34]<- results.sixmers[[i]]$opt[1]
result.comp[i,35]<- results.sixmers[[i]]$opt[2]
result.comp[i,36]<- results.sixmers[[i]]$opt[3]
}
#make a table output with all of the relevant information
result.comp <-as.data.frame(matrix(,7,42))
colnames(result.comp)<- c("model","results.bp.Mbp", "aic","par1","par1","par1","model","results.twomers", "aic","par1","par1","par1","model","results.threemers", "aic","par1","par1","par1" ,"model", "results.fourmers", "aic","par1","par1","par1", "model","results.fivemers", "aic","par1","par1","par1", "model","results.sixmers", "aic","par1","par1","par1", "model","results.totalmers", "aic","par1","par1","par1")
#fill in bp.Mbp model data
for(i in 1:7){
result.comp[i,1]<-models[i]
result.comp[i,2]<-"trees"
result.comp[i,3]<- results.bp.Mbp[[i]]$opt$aicc
result.comp[i,4]<- results.bp.Mbp[[i]]$opt[1]
result.comp[i,5]<- results.bp.Mbp[[i]]$opt[2]
result.comp[i,6]<- results.bp.Mbp[[i]]$opt[3]
}
#fill in twomers model data
for(i in 1:7){
result.comp[i,7]<-models[i]
result.comp[i,8]<-"trees"
result.comp[i,9]<- results.twomers[[i]]$opt$aicc
result.comp[i,10]<- results.twomers[[i]]$opt[1]
result.comp[i,11]<- results.twomers[[i]]$opt[2]
result.comp[i,12]<- results.twomers[[i]]$opt[3]
}
#fill in threemers model data
for(i in 1:7){
result.comp[i,13]<-models[i]
result.comp[i,14]<-"trees"
result.comp[i,15]<- results.threemers[[i]]$opt$aicc
result.comp[i,16]<- results.threemers[[i]]$opt[1]
result.comp[i,17]<- results.threemers[[i]]$opt[2]
result.comp[i,18]<- results.threemers[[i]]$opt[3]
}
#fill in fourmers model data
for(i in 1:7){
result.comp[i,19]<-models[i]
result.comp[i,20]<-"trees"
result.comp[i,21]<- results.fourmers[[i]]$opt$aicc
result.comp[i,22]<- results.fourmers[[i]]$opt[1]
result.comp[i,23]<- results.fourmers[[i]]$opt[2]
result.comp[i,24]<- results.fourmers[[i]]$opt[3]
}
#fill in fivemers model data
for(i in 1:7){
result.comp[i,25]<-models[i]
result.comp[i,26]<-"trees"
result.comp[i,27]<- results.fivemers[[i]]$opt$aicc
result.comp[i,28]<- results.fivemers[[i]]$opt[1]
result.comp[i,29]<- results.fivemers[[i]]$opt[2]
result.comp[i,30]<- results.fivemers[[i]]$opt[3]
}
#fill in sixmers model data
for(i in 1:7){
result.comp[i,31]<-models[i]
result.comp[i,32]<-"trees"
result.comp[i,33]<- results.sixmers[[i]]$opt$aicc
result.comp[i,34]<- results.sixmers[[i]]$opt[1]
result.comp[i,35]<- results.sixmers[[i]]$opt[2]
result.comp[i,36]<- results.sixmers[[i]]$opt[3]
}
#fill in totalmers model data
for(i in 1:7){
result.comp[i,37]<-models[i]
result.comp[i,38]<-"trees"
result.comp[i,39]<- results.totalmers[[i]]$opt$aicc
result.comp[i,40]<- results.totalmers[[i]]$opt[1]
result.comp[i,41]<- results.totalmers[[i]]$opt[2]
result.comp[i,42]<- results.totalmers[[i]]$opt[3]
}
View(result.comp)
?write.csv
write.csv(microsat.cent, file="phylo.sig")
write.csv(results.comp, file="phylo.sig.csv")
write.csv(result.comp, file="phylo.sig.csv")
?fitContinuous
library(phytools)
library(geiger)
#read in tree
trees <- read.nexus("../data/trees/post.nex")
trees <- trees[[sample(1:100, 1)]]
trees <- drop.tip(phy=trees, tip="B.terrestris")
trees <- drop.tip(phy=trees, tip="Plutella_xylostella")
# read in microsatellite and centromere data
microsat.cent <- read.csv("../results/ssr.inference/micRocounter_results_TII_typecentromere.csv",
row.names = 4)
#bp.Mbp vector
totalmers <- microsat.cent$all
# make named vector for bpMbp coontent
names(totalmers) <- row.names(microsat.cent)
# match up tree and data
tree <- treedata(phy = trees, data=totalmers)[[1]]
write.tree(tree, file = "tree.BAMM")
library(ape)
BAMM.tree <- read.tree("tree.BAMM.tre")
A
BAMM.tree <- read.tree("tree.BAMM")
plot(BAMM.tree)
#tree needs to be ultrametric and binary
is.ultrametric(BAMM.tree)
is.binary(BAMM.tree)
library(BAMMtools)
#does not work because data is not in correct format
setBAMMpriors(phy = BAMM.tree, traits = microsat.cent)
#does not work because data is not in correct format
setBAMMpriors(phy = BAMM.tree, traits = microsat.cent$all)
#does not work because data is not in correct format
setBAMMpriors(phy = BAMM.tree, traits = totalmers)
library(coda)
library(phytools)
library(geiger)
#read in tree
trees <- read.nexus("../data/trees/post.nex")
trees <- trees[[sample(1:100, 1)]]
trees <- drop.tip(phy=trees, tip="B.terrestris")
trees <- drop.tip(phy=trees, tip="Plutella_xylostella")
# read in microsatellite and centromere data
microsat.cent <- read.csv("../results/ssr.inference/micRocounter_results_TII_typecentromere.csv",
row.names = 4)
#bp.Mbp vector
totalmers <- microsat.cent$all
# make named vector for bpMbp coontent
names(totalmers) <- row.names(microsat.cent)
# match up tree and data
tree <- treedata(phy = trees, data=totalmers)[[1]]
write.tree(tree, file = "tree.BAMM")
library(ape)
BAMM.tree <- read.tree("tree.BAMM")
#tree needs to be ultrametric and binary
is.ultrametric(BAMM.tree)
is.binary(BAMM.tree)
library(BAMMtools)
#does not work because data is not in correct format
setBAMMpriors(phy = BAMM.tree, traits = totalmers)
microsat <- read.table("../BAMM/micRocounter_results_BAMM.csv")
View(microsat)
View(microsat)
microsat <- read.table("../BAMM/micRocounter_results_BAMM.csv", as.is = T)
View(microsat)
microsat <- read.csv("../BAMM/micRocounter_results_BAMM.csv", as.is = T)
View(microsat)
#ned to set it as the right format
BAMM.microsat <- microsat[,2]
names(BAMM.microsat) <- microsat[,1]
setBAMMpriors(phy = BAMM.tree, traits = BAMM.microsat)
library(phytools)
library(geiger)
library(ape)
library(BAMMtools)
library(coda)
library(evobiR)
# read in sampled trees
trees <- read.nexus("../data/trees/post.nex")
# select a tree at random for making a continuous trait map
tree.BAMM1 <- trees[[2]]
# read in  microsatellite data
dat.microsat <- read.csv("../results/ssr.inference/micRocounter_results_TII.csv",
as.is=T,
row.names = 4)
# fill in the column with all microsatellite content from dat.microsat
totalmers <- dat.microsat[,9]
# adds names to the bpMbp vector from dat.microsat
names(totalmers) <- row.names(dat.microsat)
# select a tree at random for making a continuous trait map
tree.BAMM2 <- trees[[2]]
# read in sampled trees
trees <- read.nexus("../data/trees/post.nex")
# select a tree at random for making a continuous trait map
tree.BAMM2 <- trees[[2]]
# read in  microsatellite data
dat.microsat <- read.csv("../results/ssr.inference/micRocounter_results_TII.csv",
as.is=T,
row.names = 4)
# fill in the column with all microsatellite content from dat.microsat
totalmers <- dat.microsat[,9]
# adds names to the bpMbp vector from dat.microsat
names(totalmers) <- row.names(dat.microsat)
#drop the tips
tree.pruned <- drop.tip(phy=tree.BAMM2, tip= c("B.terrestris", "Plutella_xylostella"))
#write the new tree into the BAMM folder
write.tree(tree.pruned, file = "tree(2).new")
#load in tree
tree.BAMM2 <- read.tree("tree(1).new")
#load in tree
tree.BAMM2 <- read.tree("tree(2).new")
#tree needs to be ultrametric and binary
is.ultrametric(tree.BAMM)
#tree needs to be ultrametric and binary
is.ultrametric(tree.BAMM2)
is.binary(tree.BAMM2)
#does not work because data is not in correct format
setBAMMpriors(phy = tree.BAMM2, traits = totalmers)
#write the new tree into the BAMM folder
write.tree(tree.pruned, file = "tree(2).new")
setwd("~/Documents/GitHub/microsat/BAMM")
# read in sampled trees
trees <- read.nexus("../data/trees/post.nex")
# select a tree at random for making a continuous trait map
tree.BAMM2 <- trees[[2]]
# read in  microsatellite data
dat.microsat <- read.csv("../results/ssr.inference/micRocounter_results_TII.csv",
as.is=T,
row.names = 4)
# fill in the column with all microsatellite content from dat.microsat
totalmers <- dat.microsat[,9]
# adds names to the bpMbp vector from dat.microsat
names(totalmers) <- row.names(dat.microsat)
#drop the tips
tree.pruned <- drop.tip(phy=tree.BAMM2, tip= c("B.terrestris", "Plutella_xylostella"))
#write the new tree into the BAMM folder
write.tree(tree.pruned, file = "tree(2).new")
#load in tree
tree.BAMM2 <- read.tree("tree(2).new")
#tree needs to be ultrametric and binary
is.ultrametric(tree.BAMM2)
is.binary(tree.BAMM2)
#does not work because data is not in correct format
setBAMMpriors(phy = tree.BAMM2, traits = totalmers)
#plot the loglike to see if it's reached convergence
mcmcout <- read.csv("totalmers.microsat.mcmc_out.txt", header =T)
plot(mcmcout$logLik ~ mcmcout$generation)
#specify 10% burnin
burnstart <- floor(0.1*nrow(mcmcout))
postburn <- mcmcout[burnstart:nrow(mcmcout),]
#came up with effective size of 735.2577
effectiveSize(postburn$N_shifts)
#came up with effective size of 415.7432
effectiveSize(postburn$logLik)
edata <- getEventData(tree.BAMM1, eventdata = "event_data.txt", burnin = 0.1, type = "trait")
edata <- getEventData(tree.BAMM2, eventdata = "event_data.txt", burnin = 0.1, type = "trait")
post_probs <- table(postburn$N_shifts)/nrow(postburn)
names(post_probs)
shift_probs <- summary(edata)
#makes a credible shift set; calculates the expected number of shifts to be most
#likely
css <- credibleShiftSet(edata, expectedNumberOfShifts = 1, threshold = 15, set.limit = 0.95)
css$number.distinct
summary(css)
plot.credibleshiftset(css)
marg_probs <- marginalShiftProbsTree(edata)
save.image("~/Documents/GitHub/microsat/BAMM/BAMM_tree2.RData")
#load in packages that are needed
library(phytools)
?plot.bammdata
#plot phylorate figures
phylorate <- plot.bammdata(edata, breaksmethod = "jenks")
#plot phylorate figures
phylorate <- plot.bammdata(edata, breaksmethod = "jenks")
ratesHistogram(phylorate, plotBrks = T, xlab = "Trait Rates")
title(main="jenks", cex.main=1)
version(phytools)
library(phytools)
R.version(phytools)
version(phytools)
version
?phytools''
?phytools
foo <- read.csv("tip.rates.csv", row.names = 1)
setwd("~/Documents/GitHub/microsat/analyses/tip.rates")
foo <- read.csv("tip.rates.csv", row.names = 1)
View(foo)
i <- 1
ave(foo[i,foo$tree.1:foo$tree.100])
ave(foo[i,])
View(foo)
?ave
?mean
mean(foo[i,])
foo[i,]
mean(foo[i,])
setwd("~/Documents/GitHub/microsat/figures")
#read in csv with rates of evolution
rates <- read.csv("../analyses/tip.rates/tip.rates.csv")
View(rates)
#store the average rate in a named vector by species name
rates <- rates$Average
#read in csv with rates of evolution
rates <- read.csv("../analyses/tip.rates/tip.rates.csv")
#store the average rate in a named vector by species name
rates.species <- rates$Average
names(rates) <- rates$
names(rates) <- rates$Average
names(rates.species) <- rates$Average
install.packages("phylolm")
#load in packages needed
library(phytools)
library(geiger)
library(phylolm)
#read in nmicrosatellite data
str <- read.csv("../data/traits/micro.vs.chrom.csv")
#read in chromosome data
chrom <- read.csv("../data/traits/data.invert.csv")
#vector of names from chromosome data
chrom.names <- paste(dat.chroms$Genus, dat.chroms$species)
#vector of names from chromosome data
chrom.names <- paste(chrom$Genus, chrom$species)
#loop that finds species diploid chromosome number from our data frame
for(i in 1:nrow(str)){
# if species in microcounter matches one in chromosome data
if(str$species[i] %in% chrom.names){
#store the name in vector hit
hit <- which(chrom.names == str$species[i])[1]
#fill in diploid number for those species that have a match in the
#chromosome data
str$diploid.num[i] <- chrom$Chromosome.number..female..2N[hit]
}
}
#make a new data frame that will contain only those species with both
#microsatellite and chromosome number data
dat.intersect <- str[complete.cases(str),]
View(dat.intersect)
#read in nmicrosatellite data
str <- read.csv("../data/traits/micro.vs.chrom.csv")
#read in chromosome data
chrom <- read.csv("../data/traits/data.invert.csv")
#vector of names from chromosome data
chrom.names <- paste(chrom$Genus, chrom$species)
#loop that finds species diploid chromosome number from our data frame
for(i in 1:nrow(str)){
# if species in microcounter matches one in chromosome data
if(str$species[i] %in% chrom.names){
#store the name in vector hit
hit <- which(chrom.names == str$species[i])[1]
#fill in diploid number for those species that have a match in the
#chromosome data
str$diploid.num[i] <- chrom$Chromosome.number..female..2N[hit]
}
}
#make a new data frame that will contain only those species with both
#microsatellite and chromosome number data
dat.intersect <- str[complete.cases(str),]
View(dat.intersect)
#write the CSV with microsatellite, genome, and diploid chromosome number data
write.csv(dat.intersect, "dat.intersect.csv")
#read in trees
trees <- read.nexus("../data/trees/post.nex")
View(dat.intersect)
#make a vector to store p-values
pvals.chrom <- c()
#loops through the 100 posterior distribution trees and determines the data
#necessary for the p-value
for(i in 1:100){
#stores tree number
tree.test <- trees[[i]]
#matches species within the dataset and the tree
foo <- treedata(phy = tree.test, data=dat.intersect)
#stores current trees data
tree.cur <- foo[[1]]
#creates data frame of the data for each tree
dat <- as.data.frame(foo[[2]])
#stores p-value on phylolm analysis
pvals.chrom[i] <- summary(phylolm(all ~ diploid.num,
data = dat,
phy = tree.cur,
model = "BM",
boot = 100))$coefficients[2,6]
}
i <- 1
tree.test <- trees[[i]]
foo <- treedata(phy = tree.test, data=dat.intersect)
tree.cur <- foo[[1]]
dat <- as.data.frame(foo[[2]])
pvals.chrom[i] <- summary(phylolm(all ~ diploid.num,
data = dat,
phy = tree.cur,
model = "BM",
boot = 100))$coefficients[2,6]
pvals.chrom[i] <- summary(phylolm(all ~ diploid.num,
data = dat.intersect,
phy = tree.cur,
model = "BM",
boot = 100))$coefficients[2,6]
View(dat)
pvals.chrom[i] <- summary(phylolm(all ~ diploid.num,
data = dat,
phy = tree.cur,
model = "BM",
boot = 100))$coefficients[2,6]
pvals.chrom[i] <- summary(phylolm(all ~ diploid.num,
data = dat.intersect,
phy = tree.cur,
model = "BM",
boot = 100))$coefficients[2,6]
View(foo)
foo[[2]]
View(dat.intersect)
tree.test <- trees[[i]]
foo <- treedata(phy = tree.test, data=dat.intersect)
View(dat.intersect)
#have to manually put in _ between species names for following code to work
#then reread in the data
dat.intersect <- read.csv("../figures/dat.intersect.csv")
foo <- treedata(phy = tree.test, data=dat.intersect)
View(foo)
trees[[1]]$tip.label
trees[[1]]$tip.label == dat.intersect$X
#have to manually put in _ between species names for following code to work
#then reread in the data
dat.intersect <- read.csv("../figures/dat.intersect.csv",
as.is = T,
row.names = 1)
foo <- treedata(phy = tree.test, data=dat.intersect)
View(foo)
foo[[2]]
View(dat.intersect)
#have to manually put in _ between species names for following code to work
#then reread in the data
dat.intersect <- read.csv("../figures/dat.intersect.csv",
as.is = T,
row.names = 1)
foo <- treedata(phy = tree.test, data=dat.intersect)
View(foo)
foo[[2]]
#loops through the 100 posterior distribution trees and determines the data
#necessary for the p-value
for(i in 1:100){
#stores tree number
tree.test <- trees[[i]]
#matches species within the dataset and the tree
foo <- treedata(phy = tree.test, data=dat.intersect)
#stores current trees data
tree.cur <- foo[[1]]
#creates data frame of the data for each tree
dat <- as.data.frame(foo[[2]])
#stores p-value on phylolm analysis
pvals.chrom[i] <- summary(phylolm(all ~ diploid.num,
data = dat.intersect,
phy = tree.cur,
model = "BM",
boot = 100))$coefficients[2,6]
}
#makes a histogram containing the p-values from the loop
hist(pvals.chrom,
main = "Chromosome Number P-Values",
xlab = "P-Values",
ylab = "Frequency of P-Values")
summary(phylolm(all ~ diploid.num,
data = dat.intersect,
phy = tree.cur,
model = "BM",
boot = 100))
#store the bp/Mbp microsatellite content
bpMbp <- dat.intersect$all/(dat.intersect$gsz/1000000)
#plot the microsatellite content in bp/Mbp and the diploid chromosome number
plot(bpMbp~dat.intersect$diploid.num,
xlab = "Diploid Number",
ylab = "Microsatellite Content (bp/Mbp)")
#plot the microsatellite content in bp/Mbp and the diploid chromosome number
plot(bpMbp~dat.intersect$diploid.num,
xlab = "Diploid Number",
ylab = "Microsatellite Content (bp/Mbp)",
pch = 20,
col = rgb(250, 159, 181, 100,
maxColorValue = 255))
#plot the microsatellite content in bp/Mbp and the diploid chromosome number
plot(bpMbp~dat.intersect$diploid.num,
xlab = "Diploid Number",
ylab = "Microsatellite Content (bp/Mbp)",
pch = 16,
col = rgb(250, 159, 181, 100,
maxColorValue = 255))
#plot the microsatellite content in bp/Mbp and the diploid chromosome number
plot(bpMbp~dat.intersect$diploid.num,
xlab = "Diploid Chromosome Number",
ylab = "Microsatellite Content (bp/Mbp)",
pch = 16,
col = rgb(250, 159, 181, 100,
maxColorValue = 255))
